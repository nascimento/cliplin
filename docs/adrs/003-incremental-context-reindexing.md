# ADR-003: Incremental Context Reindexing

## Status
Accepted

## Context

The Cliplin context store (ChromaDB) indexes documentation (ADRs, features, rules, UI intent) for semantic search and RAG. Indexing requires reading files, computing embeddings, and writing to the vector store. Reindexing **all** context files on every run is expensive and unnecessary when most files have not changed.

We need a strategy that:

1. **Avoids redundant work**: Do not re-embed or re-write documents whose content is unchanged.
2. **Stays consistent**: The same notion of "what changed" must drive both the reindex CLI command and MCP tools (e.g. "list documents that need reindexing", "has this document changed?").
3. **Remains fast**: Change detection should be cheap (no vector store or embedding calls) so dry-runs and change checks stay quick.

ADR-002 already defines a **fingerprint store** (path → content fingerprint, e.g. SHA-256) for change detection. This ADR formalizes the **decision** to use that store for **incremental reindexing**: only new or modified files trigger index operations.

## Decision

**Use fingerprint-based change detection to make reindexing incremental.** The reindex command (and any indexing workflow) MUST:

1. **Before indexing a file**: Consult the fingerprint store to determine if the file has changed (no fingerprint = new; fingerprint differs from current content = modified).
2. **Skip unchanged files**: Do not call add or update on the context store for files whose fingerprint matches the current file content.
3. **After successfully indexing a file**: Update the fingerprint store with the new fingerprint so future runs see the file as unchanged until it is edited again.

Implementation must use the shared fingerprint logic (see `docs/rules/system-modules.rules`) so that CLI reindex, MCP add/update, and any future "list changed documents" or "validate changes" command all rely on the same contract. Technical rules are prescribed in the rules file (e.g. "Incremental reindex (MUST)" in system-modules).

## Consequences

### Positive

- **Efficiency**: No redundant embeddings or writes for unchanged files; large context sets stay fast.
- **Consistency**: Dry-run and actual reindex, plus MCP tools, share one definition of "changed."
- **Traceability**: Fingerprint store supports "has this document changed?" and "list documents that need reindexing" without touching the vector store.

### Negative

- **Invalidation**: If the fingerprint store is lost or corrupted, the next full reindex will treat all files as new or modified until fingerprints are repopulated. Mitigation: store under project data path (e.g. `.cliplin/data/context/`); can be regenerated by a full reindex.

## References

- ADR-002: ChromaDB as RAG and Context Store Base (fingerprint store definition)
- Rules: system-modules — "Incremental reindex (MUST)", "Change detection and fingerprint logic (shared)"
- Feature: mcp-storage.feature — scenarios for fingerprint-based change detection
